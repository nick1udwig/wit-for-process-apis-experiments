// Generated by `wit-bindgen` 0.24.0. DO NOT EDIT!
// Options used:
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_init_cabi<T: Guest>(arg0: *mut u8,arg1: usize,) {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let len0 = arg1;
let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
T::init(_rt::string_lift(bytes0));
}
pub trait Guest {
  fn init(our: _rt::String,);
}
#[doc(hidden)]

macro_rules! __export_world_file_transfer_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "init"]
    unsafe extern "C" fn export_init(arg0: *mut u8,arg1: usize,) {
      $($path_to_types)*::_export_init_cabi::<$ty>(arg0, arg1)
    }
  };);
}
#[doc(hidden)]
pub(crate) use __export_world_file_transfer_cabi;
#[allow(dead_code)]
pub mod kinode {
  #[allow(dead_code)]
  pub mod process {
    #[allow(dead_code, clippy::all)]
    pub mod standard {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      /// System types:
      ///
      /// JSON is passed over WASM boundary as a string.
      pub type Json = _rt::String;
      pub type NodeId = _rt::String;
      /// Context, like a message body, is a protocol-defined serialized byte
      /// array. It is used when building a Request to save information that
      /// will not be part of a Response, in order to more easily handle
      /// ("contextualize") that Response.
      pub type Context = _rt::Vec::<u8>;
      #[derive(Clone)]
      pub struct ProcessId {
        pub process_name: _rt::String,
        pub package_name: _rt::String,
        pub publisher_node: NodeId,
      }
      impl ::core::fmt::Debug for ProcessId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ProcessId").field("process-name", &self.process_name).field("package-name", &self.package_name).field("publisher-node", &self.publisher_node).finish()
        }
      }
      #[derive(Clone)]
      pub struct Address {
        pub node: NodeId,
        pub process: ProcessId,
      }
      impl ::core::fmt::Debug for Address {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Address").field("node", &self.node).field("process", &self.process).finish()
        }
      }
      #[derive(Clone)]
      pub struct LazyLoadBlob {
        pub mime: Option<_rt::String>,
        pub bytes: _rt::Vec::<u8>,
      }
      impl ::core::fmt::Debug for LazyLoadBlob {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("LazyLoadBlob").field("mime", &self.mime).field("bytes", &self.bytes).finish()
        }
      }
      #[derive(Clone)]
      pub struct Capability {
        pub issuer: Address,
        pub params: Json,
      }
      impl ::core::fmt::Debug for Capability {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Capability").field("issuer", &self.issuer).field("params", &self.params).finish()
        }
      }
      #[derive(Clone)]
      pub struct Request {
        /// set in order to inherit lazy-load-blob from parent message, and if
        /// expects-response is none, direct response to source of parent.
        /// also carries forward certain aspects of parent message in kernel,
        /// see documentation for formal spec and examples.
        pub inherit: bool,
        /// if some, request expects a response in the given number of seconds
        pub expects_response: Option<u64>,
        pub body: _rt::Vec::<u8>,
        pub metadata: Option<Json>,
        pub capabilities: _rt::Vec::<Capability>,
      }
      impl ::core::fmt::Debug for Request {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Request").field("inherit", &self.inherit).field("expects-response", &self.expects_response).field("body", &self.body).field("metadata", &self.metadata).field("capabilities", &self.capabilities).finish()
        }
      }
      #[derive(Clone)]
      pub struct Response {
        pub inherit: bool,
        pub body: _rt::Vec::<u8>,
        pub metadata: Option<Json>,
        pub capabilities: _rt::Vec::<Capability>,
      }
      impl ::core::fmt::Debug for Response {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Response").field("inherit", &self.inherit).field("body", &self.body).field("metadata", &self.metadata).field("capabilities", &self.capabilities).finish()
        }
      }
      /// A message can be a request or a response. within a response, there is
      /// a result which surfaces any error that happened because of a request.
      /// A successful response will contain the context of the request it
      /// matches, if any was set.
      #[derive(Clone)]
      pub enum Message {
        Request(Request),
        Response((Response,Option<Context>,)),
      }
      impl ::core::fmt::Debug for Message {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Message::Request(e) => {
              f.debug_tuple("Message::Request").field(e).finish()
            }
            Message::Response(e) => {
              f.debug_tuple("Message::Response").field(e).finish()
            }
          }
        }
      }
      /// On-exit is a setting that determines what happens when a process
      /// panics, completes, or otherwise "ends". NOTE: requests should have
      /// expects-response set to false, will always be set to that by kernel.
      #[derive(Clone)]
      pub enum OnExit {
        None,
        Restart,
        Requests(_rt::Vec::<(Address,Request,Option<LazyLoadBlob>,)>),
      }
      impl ::core::fmt::Debug for OnExit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            OnExit::None => {
              f.debug_tuple("OnExit::None").finish()
            }
            OnExit::Restart => {
              f.debug_tuple("OnExit::Restart").finish()
            }
            OnExit::Requests(e) => {
              f.debug_tuple("OnExit::Requests").field(e).finish()
            }
          }
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum SendErrorKind {
        Offline,
        Timeout,
      }
      impl ::core::fmt::Debug for SendErrorKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            SendErrorKind::Offline => {
              f.debug_tuple("SendErrorKind::Offline").finish()
            }
            SendErrorKind::Timeout => {
              f.debug_tuple("SendErrorKind::Timeout").finish()
            }
          }
        }
      }

      impl SendErrorKind{
        pub(crate) unsafe fn _lift(val: u8) -> SendErrorKind{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => SendErrorKind::Offline,
            1 => SendErrorKind::Timeout,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Network errors come from trying to send a message to another node.
      /// A message can fail by timing out, or by the node being entirely
      /// unreachable (offline). In either case, the message is not delivered
      /// and the process that sent it receives that message along with any
      /// assigned context and/or lazy-load-blob, and is free to handle it as it
      /// sees fit. Note that if the message is a response, the process can
      /// issue a response again, and it will be directed to the same (remote)
      /// request as the original.
      #[derive(Clone)]
      pub struct SendError {
        pub kind: SendErrorKind,
        pub message: Message,
        pub lazy_load_blob: Option<LazyLoadBlob>,
      }
      impl ::core::fmt::Debug for SendError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SendError").field("kind", &self.kind).field("message", &self.message).field("lazy-load-blob", &self.lazy_load_blob).finish()
        }
      }
      impl ::core::fmt::Display for SendError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl std::error::Error for SendError {}
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum SpawnError {
        NameTaken,
        NoFileAtPath,
      }
      impl SpawnError{
        pub fn name(&self) -> &'static str {
          match self {
            SpawnError::NameTaken => "name-taken",
            SpawnError::NoFileAtPath => "no-file-at-path",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            SpawnError::NameTaken => "",
            SpawnError::NoFileAtPath => "",
          }
        }
      }
      impl ::core::fmt::Debug for SpawnError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SpawnError")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for SpawnError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl std::error::Error for SpawnError {}

      impl SpawnError{
        pub(crate) unsafe fn _lift(val: u8) -> SpawnError{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => SpawnError::NameTaken,
            1 => SpawnError::NoFileAtPath,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[allow(unused_unsafe, clippy::all)]
      /// System utils:
      pub fn print_to_terminal(verbosity: u8,message: &str,){
        unsafe {
          let vec0 = message;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "print-to-terminal"]
            fn wit_import(_: i32, _: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, _: usize, ){ unreachable!() }
          wit_import(_rt::as_i32(&verbosity), ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Process management:
      pub fn set_on_exit(on_exit: &OnExit,){
        unsafe {
          let mut cleanup_list = _rt::Vec::new();
          let (result23_0,result23_1,result23_2,) = match on_exit {
            OnExit::None=> {
              (0i32, ::core::ptr::null_mut(), 0usize)
            }
            OnExit::Restart=> {
              (1i32, ::core::ptr::null_mut(), 0usize)
            }
            OnExit::Requests(e) => {
              let vec22 = e;
              let len22 = vec22.len();
              let layout22 = _rt::alloc::Layout::from_size_align_unchecked(vec22.len() * 112, 8);
              let result22 = if layout22.size() != 0 {
                let ptr = _rt::alloc::alloc(layout22).cast::<u8>();
                if ptr.is_null()
                {
                  _rt::alloc::handle_alloc_error(layout22);
                }
                ptr
              }else {{
                ::core::ptr::null_mut()
              }};
              for (i, e) in vec22.into_iter().enumerate() {
                let base = result22.add(i * 112);
                {
                  let (t0_0, t0_1, t0_2, ) = e;
                  let Address{ node:node1, process:process1, } = t0_0;
                  let vec2 = node1;
                  let ptr2 = vec2.as_ptr().cast::<u8>();
                  let len2 = vec2.len();
                  *base.add(4).cast::<usize>() = len2;
                  *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                  let ProcessId{ process_name:process_name3, package_name:package_name3, publisher_node:publisher_node3, } = process1;
                  let vec4 = process_name3;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();
                  *base.add(12).cast::<usize>() = len4;
                  *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                  let vec5 = package_name3;
                  let ptr5 = vec5.as_ptr().cast::<u8>();
                  let len5 = vec5.len();
                  *base.add(20).cast::<usize>() = len5;
                  *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                  let vec6 = publisher_node3;
                  let ptr6 = vec6.as_ptr().cast::<u8>();
                  let len6 = vec6.len();
                  *base.add(28).cast::<usize>() = len6;
                  *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                  let Request{ inherit:inherit7, expects_response:expects_response7, body:body7, metadata:metadata7, capabilities:capabilities7, } = t0_1;
                  *base.add(32).cast::<u8>() = (match inherit7 { true => 1, false => 0 }) as u8;
                  match expects_response7 {
                    Some(e) => {
                      *base.add(40).cast::<u8>() = (1i32) as u8;
                      *base.add(48).cast::<i64>() = _rt::as_i64(e);
                    },
                    None => {
                      {
                        *base.add(40).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };let vec8 = body7;
                  let ptr8 = vec8.as_ptr().cast::<u8>();
                  let len8 = vec8.len();
                  *base.add(60).cast::<usize>() = len8;
                  *base.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                  match metadata7 {
                    Some(e) => {
                      *base.add(64).cast::<u8>() = (1i32) as u8;
                      let vec9 = e;
                      let ptr9 = vec9.as_ptr().cast::<u8>();
                      let len9 = vec9.len();
                      *base.add(72).cast::<usize>() = len9;
                      *base.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                    },
                    None => {
                      {
                        *base.add(64).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };let vec18 = capabilities7;
                  let len18 = vec18.len();
                  let layout18 = _rt::alloc::Layout::from_size_align_unchecked(vec18.len() * 40, 4);
                  let result18 = if layout18.size() != 0 {
                    let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                    if ptr.is_null()
                    {
                      _rt::alloc::handle_alloc_error(layout18);
                    }
                    ptr
                  }else {{
                    ::core::ptr::null_mut()
                  }};
                  for (i, e) in vec18.into_iter().enumerate() {
                    let base = result18.add(i * 40);
                    {
                      let Capability{ issuer:issuer10, params:params10, } = e;
                      let Address{ node:node11, process:process11, } = issuer10;
                      let vec12 = node11;
                      let ptr12 = vec12.as_ptr().cast::<u8>();
                      let len12 = vec12.len();
                      *base.add(4).cast::<usize>() = len12;
                      *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                      let ProcessId{ process_name:process_name13, package_name:package_name13, publisher_node:publisher_node13, } = process11;
                      let vec14 = process_name13;
                      let ptr14 = vec14.as_ptr().cast::<u8>();
                      let len14 = vec14.len();
                      *base.add(12).cast::<usize>() = len14;
                      *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                      let vec15 = package_name13;
                      let ptr15 = vec15.as_ptr().cast::<u8>();
                      let len15 = vec15.len();
                      *base.add(20).cast::<usize>() = len15;
                      *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                      let vec16 = publisher_node13;
                      let ptr16 = vec16.as_ptr().cast::<u8>();
                      let len16 = vec16.len();
                      *base.add(28).cast::<usize>() = len16;
                      *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                      let vec17 = params10;
                      let ptr17 = vec17.as_ptr().cast::<u8>();
                      let len17 = vec17.len();
                      *base.add(36).cast::<usize>() = len17;
                      *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                    }
                  }
                  *base.add(80).cast::<usize>() = len18;
                  *base.add(76).cast::<*mut u8>() = result18;
                  match t0_2 {
                    Some(e) => {
                      *base.add(88).cast::<u8>() = (1i32) as u8;
                      let LazyLoadBlob{ mime:mime19, bytes:bytes19, } = e;
                      match mime19 {
                        Some(e) => {
                          *base.add(92).cast::<u8>() = (1i32) as u8;
                          let vec20 = e;
                          let ptr20 = vec20.as_ptr().cast::<u8>();
                          let len20 = vec20.len();
                          *base.add(100).cast::<usize>() = len20;
                          *base.add(96).cast::<*mut u8>() = ptr20.cast_mut();
                        },
                        None => {
                          {
                            *base.add(92).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };let vec21 = bytes19;
                      let ptr21 = vec21.as_ptr().cast::<u8>();
                      let len21 = vec21.len();
                      *base.add(108).cast::<usize>() = len21;
                      *base.add(104).cast::<*mut u8>() = ptr21.cast_mut();
                    },
                    None => {
                      {
                        *base.add(88).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };cleanup_list.extend_from_slice(&[(result18, layout18),]);
                }
              }
              cleanup_list.extend_from_slice(&[(result22, layout22),]);

              (2i32, result22, len22)
            },
          };

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "set-on-exit"]
            fn wit_import(_: i32, _: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, _: usize, ){ unreachable!() }
          wit_import(result23_0, result23_1, result23_2);
          for (ptr, layout) in cleanup_list {

            if layout.size() != 0 {

              _rt::alloc::dealloc(ptr.cast(), layout);

            }

          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      pub fn get_on_exit() -> OnExit{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "get-on-exit"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          let v53 = match l1 {
            0 => {
              OnExit::None
            }
            1 => {
              OnExit::Restart
            }
            n => {
              debug_assert_eq!(n, 2, "invalid enum discriminant");
              let e53 = {
                let l2 = *ptr0.add(4).cast::<*mut u8>();
                let l3 = *ptr0.add(8).cast::<usize>();
                let base52 = l2;
                let len52 = l3;
                let mut result52 = _rt::Vec::with_capacity(len52);
                for i in 0..len52 {
                  let base = base52.add(i * 112);
                  let e52 = {
                    let l4 = *base.add(0).cast::<*mut u8>();
                    let l5 = *base.add(4).cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *base.add(8).cast::<*mut u8>();
                    let l8 = *base.add(12).cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let l10 = *base.add(16).cast::<*mut u8>();
                    let l11 = *base.add(20).cast::<usize>();
                    let len12 = l11;
                    let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                    let l13 = *base.add(24).cast::<*mut u8>();
                    let l14 = *base.add(28).cast::<usize>();
                    let len15 = l14;
                    let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);
                    let l16 = i32::from(*base.add(32).cast::<u8>());
                    let l17 = i32::from(*base.add(40).cast::<u8>());
                    let l19 = *base.add(56).cast::<*mut u8>();
                    let l20 = *base.add(60).cast::<usize>();
                    let len21 = l20;
                    let l22 = i32::from(*base.add(64).cast::<u8>());
                    let l26 = *base.add(76).cast::<*mut u8>();
                    let l27 = *base.add(80).cast::<usize>();
                    let base43 = l26;
                    let len43 = l27;
                    let mut result43 = _rt::Vec::with_capacity(len43);
                    for i in 0..len43 {
                      let base = base43.add(i * 40);
                      let e43 = {
                        let l28 = *base.add(0).cast::<*mut u8>();
                        let l29 = *base.add(4).cast::<usize>();
                        let len30 = l29;
                        let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);
                        let l31 = *base.add(8).cast::<*mut u8>();
                        let l32 = *base.add(12).cast::<usize>();
                        let len33 = l32;
                        let bytes33 = _rt::Vec::from_raw_parts(l31.cast(), len33, len33);
                        let l34 = *base.add(16).cast::<*mut u8>();
                        let l35 = *base.add(20).cast::<usize>();
                        let len36 = l35;
                        let bytes36 = _rt::Vec::from_raw_parts(l34.cast(), len36, len36);
                        let l37 = *base.add(24).cast::<*mut u8>();
                        let l38 = *base.add(28).cast::<usize>();
                        let len39 = l38;
                        let bytes39 = _rt::Vec::from_raw_parts(l37.cast(), len39, len39);
                        let l40 = *base.add(32).cast::<*mut u8>();
                        let l41 = *base.add(36).cast::<usize>();
                        let len42 = l41;
                        let bytes42 = _rt::Vec::from_raw_parts(l40.cast(), len42, len42);

                        Capability{
                          issuer: Address{
                            node: _rt::string_lift(bytes30),
                            process: ProcessId{
                              process_name: _rt::string_lift(bytes33),
                              package_name: _rt::string_lift(bytes36),
                              publisher_node: _rt::string_lift(bytes39),
                            },
                          },
                          params: _rt::string_lift(bytes42),
                        }
                      };
                      result43.push(e43);
                    }
                    _rt::cabi_dealloc(base43, len43 * 40, 4);
                    let l44 = i32::from(*base.add(88).cast::<u8>());

                    (Address{
                      node: _rt::string_lift(bytes6),
                      process: ProcessId{
                        process_name: _rt::string_lift(bytes9),
                        package_name: _rt::string_lift(bytes12),
                        publisher_node: _rt::string_lift(bytes15),
                      },
                    }, Request{
                      inherit: _rt::bool_lift(l16 as u8),
                      expects_response: match l17 {
                        0 => None,
                        1 => {
                          let e = {
                            let l18 = *base.add(48).cast::<i64>();

                            l18 as u64
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      },
                      body: _rt::Vec::from_raw_parts(l19.cast(), len21, len21),
                      metadata: match l22 {
                        0 => None,
                        1 => {
                          let e = {
                            let l23 = *base.add(68).cast::<*mut u8>();
                            let l24 = *base.add(72).cast::<usize>();
                            let len25 = l24;
                            let bytes25 = _rt::Vec::from_raw_parts(l23.cast(), len25, len25);

                            _rt::string_lift(bytes25)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      },
                      capabilities: result43,
                    }, match l44 {
                      0 => None,
                      1 => {
                        let e = {
                          let l45 = i32::from(*base.add(92).cast::<u8>());
                          let l49 = *base.add(104).cast::<*mut u8>();
                          let l50 = *base.add(108).cast::<usize>();
                          let len51 = l50;

                          LazyLoadBlob{
                            mime: match l45 {
                              0 => None,
                              1 => {
                                let e = {
                                  let l46 = *base.add(96).cast::<*mut u8>();
                                  let l47 = *base.add(100).cast::<usize>();
                                  let len48 = l47;
                                  let bytes48 = _rt::Vec::from_raw_parts(l46.cast(), len48, len48);

                                  _rt::string_lift(bytes48)
                                };
                                Some(e)
                              }
                              _ => _rt::invalid_enum_discriminant(),
                            },
                            bytes: _rt::Vec::from_raw_parts(l49.cast(), len51, len51),
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    })
                  };
                  result52.push(e52);
                }
                _rt::cabi_dealloc(base52, len52 * 112, 8);

                result52
              };
              OnExit::Requests(e53)
            }
          };
          v53
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      pub fn get_state() -> Option<_rt::Vec::<u8>>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "get-state"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => None,
            1 => {
              let e = {
                let l2 = *ptr0.add(4).cast::<*mut u8>();
                let l3 = *ptr0.add(8).cast::<usize>();
                let len4 = l3;

                _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      pub fn set_state(bytes: &[u8],){
        unsafe {
          let vec0 = bytes;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "set-state"]
            fn wit_import(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      pub fn clear_state(){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "clear-state"]
            fn wit_import();
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(){ unreachable!() }
          wit_import();
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      pub fn spawn(name: Option<&str>,wasm_path: &str,on_exit: &OnExit,request_capabilities: &[Capability],grant_capabilities: &[ProcessId],public: bool,) -> Result<ProcessId,SpawnError>{
        unsafe {
          let mut cleanup_list = _rt::Vec::new();
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 28]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
          let (result1_0,result1_1,result1_2,) = match name {
            Some(e) => {
              let vec0 = e;
              let ptr0 = vec0.as_ptr().cast::<u8>();
              let len0 = vec0.len();

              (1i32, ptr0.cast_mut(), len0)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let vec2 = wasm_path;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          let (result26_0,result26_1,result26_2,) = match on_exit {
            OnExit::None=> {
              (0i32, ::core::ptr::null_mut(), 0usize)
            }
            OnExit::Restart=> {
              (1i32, ::core::ptr::null_mut(), 0usize)
            }
            OnExit::Requests(e) => {
              let vec25 = e;
              let len25 = vec25.len();
              let layout25 = _rt::alloc::Layout::from_size_align_unchecked(vec25.len() * 112, 8);
              let result25 = if layout25.size() != 0 {
                let ptr = _rt::alloc::alloc(layout25).cast::<u8>();
                if ptr.is_null()
                {
                  _rt::alloc::handle_alloc_error(layout25);
                }
                ptr
              }else {{
                ::core::ptr::null_mut()
              }};
              for (i, e) in vec25.into_iter().enumerate() {
                let base = result25.add(i * 112);
                {
                  let (t3_0, t3_1, t3_2, ) = e;
                  let Address{ node:node4, process:process4, } = t3_0;
                  let vec5 = node4;
                  let ptr5 = vec5.as_ptr().cast::<u8>();
                  let len5 = vec5.len();
                  *base.add(4).cast::<usize>() = len5;
                  *base.add(0).cast::<*mut u8>() = ptr5.cast_mut();
                  let ProcessId{ process_name:process_name6, package_name:package_name6, publisher_node:publisher_node6, } = process4;
                  let vec7 = process_name6;
                  let ptr7 = vec7.as_ptr().cast::<u8>();
                  let len7 = vec7.len();
                  *base.add(12).cast::<usize>() = len7;
                  *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                  let vec8 = package_name6;
                  let ptr8 = vec8.as_ptr().cast::<u8>();
                  let len8 = vec8.len();
                  *base.add(20).cast::<usize>() = len8;
                  *base.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                  let vec9 = publisher_node6;
                  let ptr9 = vec9.as_ptr().cast::<u8>();
                  let len9 = vec9.len();
                  *base.add(28).cast::<usize>() = len9;
                  *base.add(24).cast::<*mut u8>() = ptr9.cast_mut();
                  let Request{ inherit:inherit10, expects_response:expects_response10, body:body10, metadata:metadata10, capabilities:capabilities10, } = t3_1;
                  *base.add(32).cast::<u8>() = (match inherit10 { true => 1, false => 0 }) as u8;
                  match expects_response10 {
                    Some(e) => {
                      *base.add(40).cast::<u8>() = (1i32) as u8;
                      *base.add(48).cast::<i64>() = _rt::as_i64(e);
                    },
                    None => {
                      {
                        *base.add(40).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };let vec11 = body10;
                  let ptr11 = vec11.as_ptr().cast::<u8>();
                  let len11 = vec11.len();
                  *base.add(60).cast::<usize>() = len11;
                  *base.add(56).cast::<*mut u8>() = ptr11.cast_mut();
                  match metadata10 {
                    Some(e) => {
                      *base.add(64).cast::<u8>() = (1i32) as u8;
                      let vec12 = e;
                      let ptr12 = vec12.as_ptr().cast::<u8>();
                      let len12 = vec12.len();
                      *base.add(72).cast::<usize>() = len12;
                      *base.add(68).cast::<*mut u8>() = ptr12.cast_mut();
                    },
                    None => {
                      {
                        *base.add(64).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };let vec21 = capabilities10;
                  let len21 = vec21.len();
                  let layout21 = _rt::alloc::Layout::from_size_align_unchecked(vec21.len() * 40, 4);
                  let result21 = if layout21.size() != 0 {
                    let ptr = _rt::alloc::alloc(layout21).cast::<u8>();
                    if ptr.is_null()
                    {
                      _rt::alloc::handle_alloc_error(layout21);
                    }
                    ptr
                  }else {{
                    ::core::ptr::null_mut()
                  }};
                  for (i, e) in vec21.into_iter().enumerate() {
                    let base = result21.add(i * 40);
                    {
                      let Capability{ issuer:issuer13, params:params13, } = e;
                      let Address{ node:node14, process:process14, } = issuer13;
                      let vec15 = node14;
                      let ptr15 = vec15.as_ptr().cast::<u8>();
                      let len15 = vec15.len();
                      *base.add(4).cast::<usize>() = len15;
                      *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                      let ProcessId{ process_name:process_name16, package_name:package_name16, publisher_node:publisher_node16, } = process14;
                      let vec17 = process_name16;
                      let ptr17 = vec17.as_ptr().cast::<u8>();
                      let len17 = vec17.len();
                      *base.add(12).cast::<usize>() = len17;
                      *base.add(8).cast::<*mut u8>() = ptr17.cast_mut();
                      let vec18 = package_name16;
                      let ptr18 = vec18.as_ptr().cast::<u8>();
                      let len18 = vec18.len();
                      *base.add(20).cast::<usize>() = len18;
                      *base.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                      let vec19 = publisher_node16;
                      let ptr19 = vec19.as_ptr().cast::<u8>();
                      let len19 = vec19.len();
                      *base.add(28).cast::<usize>() = len19;
                      *base.add(24).cast::<*mut u8>() = ptr19.cast_mut();
                      let vec20 = params13;
                      let ptr20 = vec20.as_ptr().cast::<u8>();
                      let len20 = vec20.len();
                      *base.add(36).cast::<usize>() = len20;
                      *base.add(32).cast::<*mut u8>() = ptr20.cast_mut();
                    }
                  }
                  *base.add(80).cast::<usize>() = len21;
                  *base.add(76).cast::<*mut u8>() = result21;
                  match t3_2 {
                    Some(e) => {
                      *base.add(88).cast::<u8>() = (1i32) as u8;
                      let LazyLoadBlob{ mime:mime22, bytes:bytes22, } = e;
                      match mime22 {
                        Some(e) => {
                          *base.add(92).cast::<u8>() = (1i32) as u8;
                          let vec23 = e;
                          let ptr23 = vec23.as_ptr().cast::<u8>();
                          let len23 = vec23.len();
                          *base.add(100).cast::<usize>() = len23;
                          *base.add(96).cast::<*mut u8>() = ptr23.cast_mut();
                        },
                        None => {
                          {
                            *base.add(92).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };let vec24 = bytes22;
                      let ptr24 = vec24.as_ptr().cast::<u8>();
                      let len24 = vec24.len();
                      *base.add(108).cast::<usize>() = len24;
                      *base.add(104).cast::<*mut u8>() = ptr24.cast_mut();
                    },
                    None => {
                      {
                        *base.add(88).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };cleanup_list.extend_from_slice(&[(result21, layout21),]);
                }
              }
              cleanup_list.extend_from_slice(&[(result25, layout25),]);

              (2i32, result25, len25)
            },
          };
          let vec35 = request_capabilities;
          let len35 = vec35.len();
          let layout35 = _rt::alloc::Layout::from_size_align_unchecked(vec35.len() * 40, 4);
          let result35 = if layout35.size() != 0 {
            let ptr = _rt::alloc::alloc(layout35).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout35);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec35.into_iter().enumerate() {
            let base = result35.add(i * 40);
            {
              let Capability{ issuer:issuer27, params:params27, } = e;
              let Address{ node:node28, process:process28, } = issuer27;
              let vec29 = node28;
              let ptr29 = vec29.as_ptr().cast::<u8>();
              let len29 = vec29.len();
              *base.add(4).cast::<usize>() = len29;
              *base.add(0).cast::<*mut u8>() = ptr29.cast_mut();
              let ProcessId{ process_name:process_name30, package_name:package_name30, publisher_node:publisher_node30, } = process28;
              let vec31 = process_name30;
              let ptr31 = vec31.as_ptr().cast::<u8>();
              let len31 = vec31.len();
              *base.add(12).cast::<usize>() = len31;
              *base.add(8).cast::<*mut u8>() = ptr31.cast_mut();
              let vec32 = package_name30;
              let ptr32 = vec32.as_ptr().cast::<u8>();
              let len32 = vec32.len();
              *base.add(20).cast::<usize>() = len32;
              *base.add(16).cast::<*mut u8>() = ptr32.cast_mut();
              let vec33 = publisher_node30;
              let ptr33 = vec33.as_ptr().cast::<u8>();
              let len33 = vec33.len();
              *base.add(28).cast::<usize>() = len33;
              *base.add(24).cast::<*mut u8>() = ptr33.cast_mut();
              let vec34 = params27;
              let ptr34 = vec34.as_ptr().cast::<u8>();
              let len34 = vec34.len();
              *base.add(36).cast::<usize>() = len34;
              *base.add(32).cast::<*mut u8>() = ptr34.cast_mut();
            }
          }
          let vec40 = grant_capabilities;
          let len40 = vec40.len();
          let layout40 = _rt::alloc::Layout::from_size_align_unchecked(vec40.len() * 24, 4);
          let result40 = if layout40.size() != 0 {
            let ptr = _rt::alloc::alloc(layout40).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout40);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec40.into_iter().enumerate() {
            let base = result40.add(i * 24);
            {
              let ProcessId{ process_name:process_name36, package_name:package_name36, publisher_node:publisher_node36, } = e;
              let vec37 = process_name36;
              let ptr37 = vec37.as_ptr().cast::<u8>();
              let len37 = vec37.len();
              *base.add(4).cast::<usize>() = len37;
              *base.add(0).cast::<*mut u8>() = ptr37.cast_mut();
              let vec38 = package_name36;
              let ptr38 = vec38.as_ptr().cast::<u8>();
              let len38 = vec38.len();
              *base.add(12).cast::<usize>() = len38;
              *base.add(8).cast::<*mut u8>() = ptr38.cast_mut();
              let vec39 = publisher_node36;
              let ptr39 = vec39.as_ptr().cast::<u8>();
              let len39 = vec39.len();
              *base.add(20).cast::<usize>() = len39;
              *base.add(16).cast::<*mut u8>() = ptr39.cast_mut();
            }
          }
          let ptr41 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "spawn"]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, ){ unreachable!() }
          wit_import(result1_0, result1_1, result1_2, ptr2.cast_mut(), len2, result26_0, result26_1, result26_2, result35, len35, result40, len40, match &public { true => 1, false => 0 }, ptr41);
          let l42 = i32::from(*ptr41.add(0).cast::<u8>());
          if layout35.size() != 0 {
            _rt::alloc::dealloc(result35.cast(), layout35);
          }
          if layout40.size() != 0 {
            _rt::alloc::dealloc(result40.cast(), layout40);
          }
          for (ptr, layout) in cleanup_list {

            if layout.size() != 0 {

              _rt::alloc::dealloc(ptr.cast(), layout);

            }

          }
          match l42 {
            0 => {
              let e = {
                let l43 = *ptr41.add(4).cast::<*mut u8>();
                let l44 = *ptr41.add(8).cast::<usize>();
                let len45 = l44;
                let bytes45 = _rt::Vec::from_raw_parts(l43.cast(), len45, len45);
                let l46 = *ptr41.add(12).cast::<*mut u8>();
                let l47 = *ptr41.add(16).cast::<usize>();
                let len48 = l47;
                let bytes48 = _rt::Vec::from_raw_parts(l46.cast(), len48, len48);
                let l49 = *ptr41.add(20).cast::<*mut u8>();
                let l50 = *ptr41.add(24).cast::<usize>();
                let len51 = l50;
                let bytes51 = _rt::Vec::from_raw_parts(l49.cast(), len51, len51);

                ProcessId{
                  process_name: _rt::string_lift(bytes45),
                  package_name: _rt::string_lift(bytes48),
                  publisher_node: _rt::string_lift(bytes51),
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l52 = i32::from(*ptr41.add(4).cast::<u8>());

                SpawnError::_lift(l52 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Capabilities management:
      ///
      /// Saves the capabilities to persisted process state.
      pub fn save_capabilities(caps: &[Capability],){
        unsafe {
          let vec8 = caps;
          let len8 = vec8.len();
          let layout8 = _rt::alloc::Layout::from_size_align_unchecked(vec8.len() * 40, 4);
          let result8 = if layout8.size() != 0 {
            let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout8);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec8.into_iter().enumerate() {
            let base = result8.add(i * 40);
            {
              let Capability{ issuer:issuer0, params:params0, } = e;
              let Address{ node:node1, process:process1, } = issuer0;
              let vec2 = node1;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *base.add(4).cast::<usize>() = len2;
              *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
              let ProcessId{ process_name:process_name3, package_name:package_name3, publisher_node:publisher_node3, } = process1;
              let vec4 = process_name3;
              let ptr4 = vec4.as_ptr().cast::<u8>();
              let len4 = vec4.len();
              *base.add(12).cast::<usize>() = len4;
              *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
              let vec5 = package_name3;
              let ptr5 = vec5.as_ptr().cast::<u8>();
              let len5 = vec5.len();
              *base.add(20).cast::<usize>() = len5;
              *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
              let vec6 = publisher_node3;
              let ptr6 = vec6.as_ptr().cast::<u8>();
              let len6 = vec6.len();
              *base.add(28).cast::<usize>() = len6;
              *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
              let vec7 = params0;
              let ptr7 = vec7.as_ptr().cast::<u8>();
              let len7 = vec7.len();
              *base.add(36).cast::<usize>() = len7;
              *base.add(32).cast::<*mut u8>() = ptr7.cast_mut();
            }
          }

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "save-capabilities"]
            fn wit_import(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, ){ unreachable!() }
          wit_import(result8, len8);
          if layout8.size() != 0 {
            _rt::alloc::dealloc(result8.cast(), layout8);
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Deletes the capabilities from persisted process state.
      pub fn drop_capabilities(caps: &[Capability],){
        unsafe {
          let vec8 = caps;
          let len8 = vec8.len();
          let layout8 = _rt::alloc::Layout::from_size_align_unchecked(vec8.len() * 40, 4);
          let result8 = if layout8.size() != 0 {
            let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout8);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec8.into_iter().enumerate() {
            let base = result8.add(i * 40);
            {
              let Capability{ issuer:issuer0, params:params0, } = e;
              let Address{ node:node1, process:process1, } = issuer0;
              let vec2 = node1;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *base.add(4).cast::<usize>() = len2;
              *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
              let ProcessId{ process_name:process_name3, package_name:package_name3, publisher_node:publisher_node3, } = process1;
              let vec4 = process_name3;
              let ptr4 = vec4.as_ptr().cast::<u8>();
              let len4 = vec4.len();
              *base.add(12).cast::<usize>() = len4;
              *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
              let vec5 = package_name3;
              let ptr5 = vec5.as_ptr().cast::<u8>();
              let len5 = vec5.len();
              *base.add(20).cast::<usize>() = len5;
              *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
              let vec6 = publisher_node3;
              let ptr6 = vec6.as_ptr().cast::<u8>();
              let len6 = vec6.len();
              *base.add(28).cast::<usize>() = len6;
              *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
              let vec7 = params0;
              let ptr7 = vec7.as_ptr().cast::<u8>();
              let len7 = vec7.len();
              *base.add(36).cast::<usize>() = len7;
              *base.add(32).cast::<*mut u8>() = ptr7.cast_mut();
            }
          }

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "drop-capabilities"]
            fn wit_import(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, ){ unreachable!() }
          wit_import(result8, len8);
          if layout8.size() != 0 {
            _rt::alloc::dealloc(result8.cast(), layout8);
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Gets all capabilities from persisted process state.
      pub fn our_capabilities() -> _rt::Vec::<Capability>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "our-capabilities"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = *ptr0.add(0).cast::<*mut u8>();
          let l2 = *ptr0.add(4).cast::<usize>();
          let base18 = l1;
          let len18 = l2;
          let mut result18 = _rt::Vec::with_capacity(len18);
          for i in 0..len18 {
            let base = base18.add(i * 40);
            let e18 = {
              let l3 = *base.add(0).cast::<*mut u8>();
              let l4 = *base.add(4).cast::<usize>();
              let len5 = l4;
              let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
              let l6 = *base.add(8).cast::<*mut u8>();
              let l7 = *base.add(12).cast::<usize>();
              let len8 = l7;
              let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
              let l9 = *base.add(16).cast::<*mut u8>();
              let l10 = *base.add(20).cast::<usize>();
              let len11 = l10;
              let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
              let l12 = *base.add(24).cast::<*mut u8>();
              let l13 = *base.add(28).cast::<usize>();
              let len14 = l13;
              let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);
              let l15 = *base.add(32).cast::<*mut u8>();
              let l16 = *base.add(36).cast::<usize>();
              let len17 = l16;
              let bytes17 = _rt::Vec::from_raw_parts(l15.cast(), len17, len17);

              Capability{
                issuer: Address{
                  node: _rt::string_lift(bytes5),
                  process: ProcessId{
                    process_name: _rt::string_lift(bytes8),
                    package_name: _rt::string_lift(bytes11),
                    publisher_node: _rt::string_lift(bytes14),
                  },
                },
                params: _rt::string_lift(bytes17),
              }
            };
            result18.push(e18);
          }
          _rt::cabi_dealloc(base18, len18 * 40, 4);
          result18
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Message I/O:
      ///
      /// Ingest next message when it arrives along with its source.
      /// Almost all long-running processes will call this in a loop.
      pub fn receive() -> Result<(Address,Message,),(SendError,Option<Context>,)>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 120]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 120]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "receive"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = {
                let l2 = *ptr0.add(8).cast::<*mut u8>();
                let l3 = *ptr0.add(12).cast::<usize>();
                let len4 = l3;
                let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                let l5 = *ptr0.add(16).cast::<*mut u8>();
                let l6 = *ptr0.add(20).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                let l8 = *ptr0.add(24).cast::<*mut u8>();
                let l9 = *ptr0.add(28).cast::<usize>();
                let len10 = l9;
                let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                let l11 = *ptr0.add(32).cast::<*mut u8>();
                let l12 = *ptr0.add(36).cast::<usize>();
                let len13 = l12;
                let bytes13 = _rt::Vec::from_raw_parts(l11.cast(), len13, len13);
                let l14 = i32::from(*ptr0.add(40).cast::<u8>());
                let v73 = match l14 {
                  0 => {
                    let e73 = {
                      let l15 = i32::from(*ptr0.add(48).cast::<u8>());
                      let l16 = i32::from(*ptr0.add(56).cast::<u8>());
                      let l18 = *ptr0.add(72).cast::<*mut u8>();
                      let l19 = *ptr0.add(76).cast::<usize>();
                      let len20 = l19;
                      let l21 = i32::from(*ptr0.add(80).cast::<u8>());
                      let l25 = *ptr0.add(92).cast::<*mut u8>();
                      let l26 = *ptr0.add(96).cast::<usize>();
                      let base42 = l25;
                      let len42 = l26;
                      let mut result42 = _rt::Vec::with_capacity(len42);
                      for i in 0..len42 {
                        let base = base42.add(i * 40);
                        let e42 = {
                          let l27 = *base.add(0).cast::<*mut u8>();
                          let l28 = *base.add(4).cast::<usize>();
                          let len29 = l28;
                          let bytes29 = _rt::Vec::from_raw_parts(l27.cast(), len29, len29);
                          let l30 = *base.add(8).cast::<*mut u8>();
                          let l31 = *base.add(12).cast::<usize>();
                          let len32 = l31;
                          let bytes32 = _rt::Vec::from_raw_parts(l30.cast(), len32, len32);
                          let l33 = *base.add(16).cast::<*mut u8>();
                          let l34 = *base.add(20).cast::<usize>();
                          let len35 = l34;
                          let bytes35 = _rt::Vec::from_raw_parts(l33.cast(), len35, len35);
                          let l36 = *base.add(24).cast::<*mut u8>();
                          let l37 = *base.add(28).cast::<usize>();
                          let len38 = l37;
                          let bytes38 = _rt::Vec::from_raw_parts(l36.cast(), len38, len38);
                          let l39 = *base.add(32).cast::<*mut u8>();
                          let l40 = *base.add(36).cast::<usize>();
                          let len41 = l40;
                          let bytes41 = _rt::Vec::from_raw_parts(l39.cast(), len41, len41);

                          Capability{
                            issuer: Address{
                              node: _rt::string_lift(bytes29),
                              process: ProcessId{
                                process_name: _rt::string_lift(bytes32),
                                package_name: _rt::string_lift(bytes35),
                                publisher_node: _rt::string_lift(bytes38),
                              },
                            },
                            params: _rt::string_lift(bytes41),
                          }
                        };
                        result42.push(e42);
                      }
                      _rt::cabi_dealloc(base42, len42 * 40, 4);

                      Request{
                        inherit: _rt::bool_lift(l15 as u8),
                        expects_response: match l16 {
                          0 => None,
                          1 => {
                            let e = {
                              let l17 = *ptr0.add(64).cast::<i64>();

                              l17 as u64
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        body: _rt::Vec::from_raw_parts(l18.cast(), len20, len20),
                        metadata: match l21 {
                          0 => None,
                          1 => {
                            let e = {
                              let l22 = *ptr0.add(84).cast::<*mut u8>();
                              let l23 = *ptr0.add(88).cast::<usize>();
                              let len24 = l23;
                              let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);

                              _rt::string_lift(bytes24)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        capabilities: result42,
                      }
                    };
                    Message::Request(e73)
                  }
                  n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e73 = {
                      let l43 = i32::from(*ptr0.add(48).cast::<u8>());
                      let l44 = *ptr0.add(52).cast::<*mut u8>();
                      let l45 = *ptr0.add(56).cast::<usize>();
                      let len46 = l45;
                      let l47 = i32::from(*ptr0.add(60).cast::<u8>());
                      let l51 = *ptr0.add(72).cast::<*mut u8>();
                      let l52 = *ptr0.add(76).cast::<usize>();
                      let base68 = l51;
                      let len68 = l52;
                      let mut result68 = _rt::Vec::with_capacity(len68);
                      for i in 0..len68 {
                        let base = base68.add(i * 40);
                        let e68 = {
                          let l53 = *base.add(0).cast::<*mut u8>();
                          let l54 = *base.add(4).cast::<usize>();
                          let len55 = l54;
                          let bytes55 = _rt::Vec::from_raw_parts(l53.cast(), len55, len55);
                          let l56 = *base.add(8).cast::<*mut u8>();
                          let l57 = *base.add(12).cast::<usize>();
                          let len58 = l57;
                          let bytes58 = _rt::Vec::from_raw_parts(l56.cast(), len58, len58);
                          let l59 = *base.add(16).cast::<*mut u8>();
                          let l60 = *base.add(20).cast::<usize>();
                          let len61 = l60;
                          let bytes61 = _rt::Vec::from_raw_parts(l59.cast(), len61, len61);
                          let l62 = *base.add(24).cast::<*mut u8>();
                          let l63 = *base.add(28).cast::<usize>();
                          let len64 = l63;
                          let bytes64 = _rt::Vec::from_raw_parts(l62.cast(), len64, len64);
                          let l65 = *base.add(32).cast::<*mut u8>();
                          let l66 = *base.add(36).cast::<usize>();
                          let len67 = l66;
                          let bytes67 = _rt::Vec::from_raw_parts(l65.cast(), len67, len67);

                          Capability{
                            issuer: Address{
                              node: _rt::string_lift(bytes55),
                              process: ProcessId{
                                process_name: _rt::string_lift(bytes58),
                                package_name: _rt::string_lift(bytes61),
                                publisher_node: _rt::string_lift(bytes64),
                              },
                            },
                            params: _rt::string_lift(bytes67),
                          }
                        };
                        result68.push(e68);
                      }
                      _rt::cabi_dealloc(base68, len68 * 40, 4);
                      let l69 = i32::from(*ptr0.add(80).cast::<u8>());

                      (Response{
                        inherit: _rt::bool_lift(l43 as u8),
                        body: _rt::Vec::from_raw_parts(l44.cast(), len46, len46),
                        metadata: match l47 {
                          0 => None,
                          1 => {
                            let e = {
                              let l48 = *ptr0.add(64).cast::<*mut u8>();
                              let l49 = *ptr0.add(68).cast::<usize>();
                              let len50 = l49;
                              let bytes50 = _rt::Vec::from_raw_parts(l48.cast(), len50, len50);

                              _rt::string_lift(bytes50)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        capabilities: result68,
                      }, match l69 {
                        0 => None,
                        1 => {
                          let e = {
                            let l70 = *ptr0.add(84).cast::<*mut u8>();
                            let l71 = *ptr0.add(88).cast::<usize>();
                            let len72 = l71;

                            _rt::Vec::from_raw_parts(l70.cast(), len72, len72)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      })
                    };
                    Message::Response(e73)
                  }
                };

                (Address{
                  node: _rt::string_lift(bytes4),
                  process: ProcessId{
                    process_name: _rt::string_lift(bytes7),
                    package_name: _rt::string_lift(bytes10),
                    publisher_node: _rt::string_lift(bytes13),
                  },
                }, v73)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l74 = i32::from(*ptr0.add(8).cast::<u8>());
                let l75 = i32::from(*ptr0.add(16).cast::<u8>());
                let v134 = match l75 {
                  0 => {
                    let e134 = {
                      let l76 = i32::from(*ptr0.add(24).cast::<u8>());
                      let l77 = i32::from(*ptr0.add(32).cast::<u8>());
                      let l79 = *ptr0.add(48).cast::<*mut u8>();
                      let l80 = *ptr0.add(52).cast::<usize>();
                      let len81 = l80;
                      let l82 = i32::from(*ptr0.add(56).cast::<u8>());
                      let l86 = *ptr0.add(68).cast::<*mut u8>();
                      let l87 = *ptr0.add(72).cast::<usize>();
                      let base103 = l86;
                      let len103 = l87;
                      let mut result103 = _rt::Vec::with_capacity(len103);
                      for i in 0..len103 {
                        let base = base103.add(i * 40);
                        let e103 = {
                          let l88 = *base.add(0).cast::<*mut u8>();
                          let l89 = *base.add(4).cast::<usize>();
                          let len90 = l89;
                          let bytes90 = _rt::Vec::from_raw_parts(l88.cast(), len90, len90);
                          let l91 = *base.add(8).cast::<*mut u8>();
                          let l92 = *base.add(12).cast::<usize>();
                          let len93 = l92;
                          let bytes93 = _rt::Vec::from_raw_parts(l91.cast(), len93, len93);
                          let l94 = *base.add(16).cast::<*mut u8>();
                          let l95 = *base.add(20).cast::<usize>();
                          let len96 = l95;
                          let bytes96 = _rt::Vec::from_raw_parts(l94.cast(), len96, len96);
                          let l97 = *base.add(24).cast::<*mut u8>();
                          let l98 = *base.add(28).cast::<usize>();
                          let len99 = l98;
                          let bytes99 = _rt::Vec::from_raw_parts(l97.cast(), len99, len99);
                          let l100 = *base.add(32).cast::<*mut u8>();
                          let l101 = *base.add(36).cast::<usize>();
                          let len102 = l101;
                          let bytes102 = _rt::Vec::from_raw_parts(l100.cast(), len102, len102);

                          Capability{
                            issuer: Address{
                              node: _rt::string_lift(bytes90),
                              process: ProcessId{
                                process_name: _rt::string_lift(bytes93),
                                package_name: _rt::string_lift(bytes96),
                                publisher_node: _rt::string_lift(bytes99),
                              },
                            },
                            params: _rt::string_lift(bytes102),
                          }
                        };
                        result103.push(e103);
                      }
                      _rt::cabi_dealloc(base103, len103 * 40, 4);

                      Request{
                        inherit: _rt::bool_lift(l76 as u8),
                        expects_response: match l77 {
                          0 => None,
                          1 => {
                            let e = {
                              let l78 = *ptr0.add(40).cast::<i64>();

                              l78 as u64
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        body: _rt::Vec::from_raw_parts(l79.cast(), len81, len81),
                        metadata: match l82 {
                          0 => None,
                          1 => {
                            let e = {
                              let l83 = *ptr0.add(60).cast::<*mut u8>();
                              let l84 = *ptr0.add(64).cast::<usize>();
                              let len85 = l84;
                              let bytes85 = _rt::Vec::from_raw_parts(l83.cast(), len85, len85);

                              _rt::string_lift(bytes85)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        capabilities: result103,
                      }
                    };
                    Message::Request(e134)
                  }
                  n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e134 = {
                      let l104 = i32::from(*ptr0.add(24).cast::<u8>());
                      let l105 = *ptr0.add(28).cast::<*mut u8>();
                      let l106 = *ptr0.add(32).cast::<usize>();
                      let len107 = l106;
                      let l108 = i32::from(*ptr0.add(36).cast::<u8>());
                      let l112 = *ptr0.add(48).cast::<*mut u8>();
                      let l113 = *ptr0.add(52).cast::<usize>();
                      let base129 = l112;
                      let len129 = l113;
                      let mut result129 = _rt::Vec::with_capacity(len129);
                      for i in 0..len129 {
                        let base = base129.add(i * 40);
                        let e129 = {
                          let l114 = *base.add(0).cast::<*mut u8>();
                          let l115 = *base.add(4).cast::<usize>();
                          let len116 = l115;
                          let bytes116 = _rt::Vec::from_raw_parts(l114.cast(), len116, len116);
                          let l117 = *base.add(8).cast::<*mut u8>();
                          let l118 = *base.add(12).cast::<usize>();
                          let len119 = l118;
                          let bytes119 = _rt::Vec::from_raw_parts(l117.cast(), len119, len119);
                          let l120 = *base.add(16).cast::<*mut u8>();
                          let l121 = *base.add(20).cast::<usize>();
                          let len122 = l121;
                          let bytes122 = _rt::Vec::from_raw_parts(l120.cast(), len122, len122);
                          let l123 = *base.add(24).cast::<*mut u8>();
                          let l124 = *base.add(28).cast::<usize>();
                          let len125 = l124;
                          let bytes125 = _rt::Vec::from_raw_parts(l123.cast(), len125, len125);
                          let l126 = *base.add(32).cast::<*mut u8>();
                          let l127 = *base.add(36).cast::<usize>();
                          let len128 = l127;
                          let bytes128 = _rt::Vec::from_raw_parts(l126.cast(), len128, len128);

                          Capability{
                            issuer: Address{
                              node: _rt::string_lift(bytes116),
                              process: ProcessId{
                                process_name: _rt::string_lift(bytes119),
                                package_name: _rt::string_lift(bytes122),
                                publisher_node: _rt::string_lift(bytes125),
                              },
                            },
                            params: _rt::string_lift(bytes128),
                          }
                        };
                        result129.push(e129);
                      }
                      _rt::cabi_dealloc(base129, len129 * 40, 4);
                      let l130 = i32::from(*ptr0.add(56).cast::<u8>());

                      (Response{
                        inherit: _rt::bool_lift(l104 as u8),
                        body: _rt::Vec::from_raw_parts(l105.cast(), len107, len107),
                        metadata: match l108 {
                          0 => None,
                          1 => {
                            let e = {
                              let l109 = *ptr0.add(40).cast::<*mut u8>();
                              let l110 = *ptr0.add(44).cast::<usize>();
                              let len111 = l110;
                              let bytes111 = _rt::Vec::from_raw_parts(l109.cast(), len111, len111);

                              _rt::string_lift(bytes111)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        capabilities: result129,
                      }, match l130 {
                        0 => None,
                        1 => {
                          let e = {
                            let l131 = *ptr0.add(60).cast::<*mut u8>();
                            let l132 = *ptr0.add(64).cast::<usize>();
                            let len133 = l132;

                            _rt::Vec::from_raw_parts(l131.cast(), len133, len133)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      })
                    };
                    Message::Response(e134)
                  }
                };
                let l135 = i32::from(*ptr0.add(80).cast::<u8>());
                let l143 = i32::from(*ptr0.add(104).cast::<u8>());

                (SendError{
                  kind: SendErrorKind::_lift(l74 as u8),
                  message: v134,
                  lazy_load_blob: match l135 {
                    0 => None,
                    1 => {
                      let e = {
                        let l136 = i32::from(*ptr0.add(84).cast::<u8>());
                        let l140 = *ptr0.add(96).cast::<*mut u8>();
                        let l141 = *ptr0.add(100).cast::<usize>();
                        let len142 = l141;

                        LazyLoadBlob{
                          mime: match l136 {
                            0 => None,
                            1 => {
                              let e = {
                                let l137 = *ptr0.add(88).cast::<*mut u8>();
                                let l138 = *ptr0.add(92).cast::<usize>();
                                let len139 = l138;
                                let bytes139 = _rt::Vec::from_raw_parts(l137.cast(), len139, len139);

                                _rt::string_lift(bytes139)
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                          bytes: _rt::Vec::from_raw_parts(l140.cast(), len142, len142),
                        }
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }, match l143 {
                  0 => None,
                  1 => {
                    let e = {
                      let l144 = *ptr0.add(108).cast::<*mut u8>();
                      let l145 = *ptr0.add(112).cast::<usize>();
                      let len146 = l145;

                      _rt::Vec::from_raw_parts(l144.cast(), len146, len146)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                })
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Gets lazy-load-blob, if any, of the message we most recently received.
      pub fn get_blob() -> Option<LazyLoadBlob>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "get-blob"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => None,
            1 => {
              let e = {
                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                let l6 = *ptr0.add(16).cast::<*mut u8>();
                let l7 = *ptr0.add(20).cast::<usize>();
                let len8 = l7;

                LazyLoadBlob{
                  mime: match l2 {
                    0 => None,
                    1 => {
                      let e = {
                        let l3 = *ptr0.add(8).cast::<*mut u8>();
                        let l4 = *ptr0.add(12).cast::<usize>();
                        let len5 = l4;
                        let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

                        _rt::string_lift(bytes5)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                  bytes: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
                }
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Send message(s) to target(s).
      pub fn send_request(target: &Address,request: &Request,context: Option<&Context>,lazy_load_blob: Option<&LazyLoadBlob>,){
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 128]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 128]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let Address{ node:node1, process:process1, } = target;
          let vec2 = node1;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          *ptr0.add(4).cast::<usize>() = len2;
          *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
          let ProcessId{ process_name:process_name3, package_name:package_name3, publisher_node:publisher_node3, } = process1;
          let vec4 = process_name3;
          let ptr4 = vec4.as_ptr().cast::<u8>();
          let len4 = vec4.len();
          *ptr0.add(12).cast::<usize>() = len4;
          *ptr0.add(8).cast::<*mut u8>() = ptr4.cast_mut();
          let vec5 = package_name3;
          let ptr5 = vec5.as_ptr().cast::<u8>();
          let len5 = vec5.len();
          *ptr0.add(20).cast::<usize>() = len5;
          *ptr0.add(16).cast::<*mut u8>() = ptr5.cast_mut();
          let vec6 = publisher_node3;
          let ptr6 = vec6.as_ptr().cast::<u8>();
          let len6 = vec6.len();
          *ptr0.add(28).cast::<usize>() = len6;
          *ptr0.add(24).cast::<*mut u8>() = ptr6.cast_mut();
          let Request{ inherit:inherit7, expects_response:expects_response7, body:body7, metadata:metadata7, capabilities:capabilities7, } = request;
          *ptr0.add(32).cast::<u8>() = (match inherit7 { true => 1, false => 0 }) as u8;
          match expects_response7 {
            Some(e) => {
              *ptr0.add(40).cast::<u8>() = (1i32) as u8;
              *ptr0.add(48).cast::<i64>() = _rt::as_i64(e);
            },
            None => {
              {
                *ptr0.add(40).cast::<u8>() = (0i32) as u8;
              }
            },
          };let vec8 = body7;
          let ptr8 = vec8.as_ptr().cast::<u8>();
          let len8 = vec8.len();
          *ptr0.add(60).cast::<usize>() = len8;
          *ptr0.add(56).cast::<*mut u8>() = ptr8.cast_mut();
          match metadata7 {
            Some(e) => {
              *ptr0.add(64).cast::<u8>() = (1i32) as u8;
              let vec9 = e;
              let ptr9 = vec9.as_ptr().cast::<u8>();
              let len9 = vec9.len();
              *ptr0.add(72).cast::<usize>() = len9;
              *ptr0.add(68).cast::<*mut u8>() = ptr9.cast_mut();
            },
            None => {
              {
                *ptr0.add(64).cast::<u8>() = (0i32) as u8;
              }
            },
          };let vec18 = capabilities7;
          let len18 = vec18.len();
          let layout18 = _rt::alloc::Layout::from_size_align_unchecked(vec18.len() * 40, 4);
          let result18 = if layout18.size() != 0 {
            let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout18);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec18.into_iter().enumerate() {
            let base = result18.add(i * 40);
            {
              let Capability{ issuer:issuer10, params:params10, } = e;
              let Address{ node:node11, process:process11, } = issuer10;
              let vec12 = node11;
              let ptr12 = vec12.as_ptr().cast::<u8>();
              let len12 = vec12.len();
              *base.add(4).cast::<usize>() = len12;
              *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
              let ProcessId{ process_name:process_name13, package_name:package_name13, publisher_node:publisher_node13, } = process11;
              let vec14 = process_name13;
              let ptr14 = vec14.as_ptr().cast::<u8>();
              let len14 = vec14.len();
              *base.add(12).cast::<usize>() = len14;
              *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
              let vec15 = package_name13;
              let ptr15 = vec15.as_ptr().cast::<u8>();
              let len15 = vec15.len();
              *base.add(20).cast::<usize>() = len15;
              *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
              let vec16 = publisher_node13;
              let ptr16 = vec16.as_ptr().cast::<u8>();
              let len16 = vec16.len();
              *base.add(28).cast::<usize>() = len16;
              *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
              let vec17 = params10;
              let ptr17 = vec17.as_ptr().cast::<u8>();
              let len17 = vec17.len();
              *base.add(36).cast::<usize>() = len17;
              *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
            }
          }
          *ptr0.add(80).cast::<usize>() = len18;
          *ptr0.add(76).cast::<*mut u8>() = result18;
          match context {
            Some(e) => {
              *ptr0.add(88).cast::<u8>() = (1i32) as u8;
              let vec19 = e;
              let ptr19 = vec19.as_ptr().cast::<u8>();
              let len19 = vec19.len();
              *ptr0.add(96).cast::<usize>() = len19;
              *ptr0.add(92).cast::<*mut u8>() = ptr19.cast_mut();
            },
            None => {
              {
                *ptr0.add(88).cast::<u8>() = (0i32) as u8;
              }
            },
          };match lazy_load_blob {
            Some(e) => {
              *ptr0.add(100).cast::<u8>() = (1i32) as u8;
              let LazyLoadBlob{ mime:mime20, bytes:bytes20, } = e;
              match mime20 {
                Some(e) => {
                  *ptr0.add(104).cast::<u8>() = (1i32) as u8;
                  let vec21 = e;
                  let ptr21 = vec21.as_ptr().cast::<u8>();
                  let len21 = vec21.len();
                  *ptr0.add(112).cast::<usize>() = len21;
                  *ptr0.add(108).cast::<*mut u8>() = ptr21.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(104).cast::<u8>() = (0i32) as u8;
                  }
                },
              };let vec22 = bytes20;
              let ptr22 = vec22.as_ptr().cast::<u8>();
              let len22 = vec22.len();
              *ptr0.add(120).cast::<usize>() = len22;
              *ptr0.add(116).cast::<*mut u8>() = ptr22.cast_mut();
            },
            None => {
              {
                *ptr0.add(100).cast::<u8>() = (0i32) as u8;
              }
            },
          };
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "send-request"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          if layout18.size() != 0 {
            _rt::alloc::dealloc(result18.cast(), layout18);
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      pub fn send_requests(requests: &[(Address,Request,Option<Context>,Option<LazyLoadBlob>,)],){
        unsafe {
          let mut cleanup_list = _rt::Vec::new();
          let vec23 = requests;
          let len23 = vec23.len();
          let layout23 = _rt::alloc::Layout::from_size_align_unchecked(vec23.len() * 128, 8);
          let result23 = if layout23.size() != 0 {
            let ptr = _rt::alloc::alloc(layout23).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout23);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec23.into_iter().enumerate() {
            let base = result23.add(i * 128);
            {
              let (t0_0, t0_1, t0_2, t0_3, ) = e;
              let Address{ node:node1, process:process1, } = t0_0;
              let vec2 = node1;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *base.add(4).cast::<usize>() = len2;
              *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
              let ProcessId{ process_name:process_name3, package_name:package_name3, publisher_node:publisher_node3, } = process1;
              let vec4 = process_name3;
              let ptr4 = vec4.as_ptr().cast::<u8>();
              let len4 = vec4.len();
              *base.add(12).cast::<usize>() = len4;
              *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
              let vec5 = package_name3;
              let ptr5 = vec5.as_ptr().cast::<u8>();
              let len5 = vec5.len();
              *base.add(20).cast::<usize>() = len5;
              *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
              let vec6 = publisher_node3;
              let ptr6 = vec6.as_ptr().cast::<u8>();
              let len6 = vec6.len();
              *base.add(28).cast::<usize>() = len6;
              *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
              let Request{ inherit:inherit7, expects_response:expects_response7, body:body7, metadata:metadata7, capabilities:capabilities7, } = t0_1;
              *base.add(32).cast::<u8>() = (match inherit7 { true => 1, false => 0 }) as u8;
              match expects_response7 {
                Some(e) => {
                  *base.add(40).cast::<u8>() = (1i32) as u8;
                  *base.add(48).cast::<i64>() = _rt::as_i64(e);
                },
                None => {
                  {
                    *base.add(40).cast::<u8>() = (0i32) as u8;
                  }
                },
              };let vec8 = body7;
              let ptr8 = vec8.as_ptr().cast::<u8>();
              let len8 = vec8.len();
              *base.add(60).cast::<usize>() = len8;
              *base.add(56).cast::<*mut u8>() = ptr8.cast_mut();
              match metadata7 {
                Some(e) => {
                  *base.add(64).cast::<u8>() = (1i32) as u8;
                  let vec9 = e;
                  let ptr9 = vec9.as_ptr().cast::<u8>();
                  let len9 = vec9.len();
                  *base.add(72).cast::<usize>() = len9;
                  *base.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                },
                None => {
                  {
                    *base.add(64).cast::<u8>() = (0i32) as u8;
                  }
                },
              };let vec18 = capabilities7;
              let len18 = vec18.len();
              let layout18 = _rt::alloc::Layout::from_size_align_unchecked(vec18.len() * 40, 4);
              let result18 = if layout18.size() != 0 {
                let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                if ptr.is_null()
                {
                  _rt::alloc::handle_alloc_error(layout18);
                }
                ptr
              }else {{
                ::core::ptr::null_mut()
              }};
              for (i, e) in vec18.into_iter().enumerate() {
                let base = result18.add(i * 40);
                {
                  let Capability{ issuer:issuer10, params:params10, } = e;
                  let Address{ node:node11, process:process11, } = issuer10;
                  let vec12 = node11;
                  let ptr12 = vec12.as_ptr().cast::<u8>();
                  let len12 = vec12.len();
                  *base.add(4).cast::<usize>() = len12;
                  *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                  let ProcessId{ process_name:process_name13, package_name:package_name13, publisher_node:publisher_node13, } = process11;
                  let vec14 = process_name13;
                  let ptr14 = vec14.as_ptr().cast::<u8>();
                  let len14 = vec14.len();
                  *base.add(12).cast::<usize>() = len14;
                  *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                  let vec15 = package_name13;
                  let ptr15 = vec15.as_ptr().cast::<u8>();
                  let len15 = vec15.len();
                  *base.add(20).cast::<usize>() = len15;
                  *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                  let vec16 = publisher_node13;
                  let ptr16 = vec16.as_ptr().cast::<u8>();
                  let len16 = vec16.len();
                  *base.add(28).cast::<usize>() = len16;
                  *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                  let vec17 = params10;
                  let ptr17 = vec17.as_ptr().cast::<u8>();
                  let len17 = vec17.len();
                  *base.add(36).cast::<usize>() = len17;
                  *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                }
              }
              *base.add(80).cast::<usize>() = len18;
              *base.add(76).cast::<*mut u8>() = result18;
              match t0_2 {
                Some(e) => {
                  *base.add(88).cast::<u8>() = (1i32) as u8;
                  let vec19 = e;
                  let ptr19 = vec19.as_ptr().cast::<u8>();
                  let len19 = vec19.len();
                  *base.add(96).cast::<usize>() = len19;
                  *base.add(92).cast::<*mut u8>() = ptr19.cast_mut();
                },
                None => {
                  {
                    *base.add(88).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match t0_3 {
                Some(e) => {
                  *base.add(100).cast::<u8>() = (1i32) as u8;
                  let LazyLoadBlob{ mime:mime20, bytes:bytes20, } = e;
                  match mime20 {
                    Some(e) => {
                      *base.add(104).cast::<u8>() = (1i32) as u8;
                      let vec21 = e;
                      let ptr21 = vec21.as_ptr().cast::<u8>();
                      let len21 = vec21.len();
                      *base.add(112).cast::<usize>() = len21;
                      *base.add(108).cast::<*mut u8>() = ptr21.cast_mut();
                    },
                    None => {
                      {
                        *base.add(104).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };let vec22 = bytes20;
                  let ptr22 = vec22.as_ptr().cast::<u8>();
                  let len22 = vec22.len();
                  *base.add(120).cast::<usize>() = len22;
                  *base.add(116).cast::<*mut u8>() = ptr22.cast_mut();
                },
                None => {
                  {
                    *base.add(100).cast::<u8>() = (0i32) as u8;
                  }
                },
              };cleanup_list.extend_from_slice(&[(result18, layout18),]);
            }
          }

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "send-requests"]
            fn wit_import(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, ){ unreachable!() }
          wit_import(result23, len23);
          if layout23.size() != 0 {
            _rt::alloc::dealloc(result23.cast(), layout23);
          }
          for (ptr, layout) in cleanup_list {

            if layout.size() != 0 {

              _rt::alloc::dealloc(ptr.cast(), layout);

            }

          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      pub fn send_response(response: &Response,lazy_load_blob: Option<&LazyLoadBlob>,){
        unsafe {
          let Response{ inherit:inherit0, body:body0, metadata:metadata0, capabilities:capabilities0, } = response;
          let vec1 = body0;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let (result3_0,result3_1,result3_2,) = match metadata0 {
            Some(e) => {
              let vec2 = e;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();

              (1i32, ptr2.cast_mut(), len2)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let vec12 = capabilities0;
          let len12 = vec12.len();
          let layout12 = _rt::alloc::Layout::from_size_align_unchecked(vec12.len() * 40, 4);
          let result12 = if layout12.size() != 0 {
            let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout12);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec12.into_iter().enumerate() {
            let base = result12.add(i * 40);
            {
              let Capability{ issuer:issuer4, params:params4, } = e;
              let Address{ node:node5, process:process5, } = issuer4;
              let vec6 = node5;
              let ptr6 = vec6.as_ptr().cast::<u8>();
              let len6 = vec6.len();
              *base.add(4).cast::<usize>() = len6;
              *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
              let ProcessId{ process_name:process_name7, package_name:package_name7, publisher_node:publisher_node7, } = process5;
              let vec8 = process_name7;
              let ptr8 = vec8.as_ptr().cast::<u8>();
              let len8 = vec8.len();
              *base.add(12).cast::<usize>() = len8;
              *base.add(8).cast::<*mut u8>() = ptr8.cast_mut();
              let vec9 = package_name7;
              let ptr9 = vec9.as_ptr().cast::<u8>();
              let len9 = vec9.len();
              *base.add(20).cast::<usize>() = len9;
              *base.add(16).cast::<*mut u8>() = ptr9.cast_mut();
              let vec10 = publisher_node7;
              let ptr10 = vec10.as_ptr().cast::<u8>();
              let len10 = vec10.len();
              *base.add(28).cast::<usize>() = len10;
              *base.add(24).cast::<*mut u8>() = ptr10.cast_mut();
              let vec11 = params4;
              let ptr11 = vec11.as_ptr().cast::<u8>();
              let len11 = vec11.len();
              *base.add(36).cast::<usize>() = len11;
              *base.add(32).cast::<*mut u8>() = ptr11.cast_mut();
            }
          }
          let (result17_0,result17_1,result17_2,result17_3,result17_4,result17_5,) = match lazy_load_blob {
            Some(e) => {
              let LazyLoadBlob{ mime:mime13, bytes:bytes13, } = e;
              let (result15_0,result15_1,result15_2,) = match mime13 {
                Some(e) => {
                  let vec14 = e;
                  let ptr14 = vec14.as_ptr().cast::<u8>();
                  let len14 = vec14.len();

                  (1i32, ptr14.cast_mut(), len14)
                },
                None => {
                  (0i32, ::core::ptr::null_mut(), 0usize)
                },
              };let vec16 = bytes13;
              let ptr16 = vec16.as_ptr().cast::<u8>();
              let len16 = vec16.len();

              (1i32, result15_0, result15_1, result15_2, ptr16.cast_mut(), len16)
            },
            None => {
              (0i32, 0i32, ::core::ptr::null_mut(), 0usize, ::core::ptr::null_mut(), 0usize)
            },
          };
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "send-response"]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, ){ unreachable!() }
          wit_import(match inherit0 { true => 1, false => 0 }, ptr1.cast_mut(), len1, result3_0, result3_1, result3_2, result12, len12, result17_0, result17_1, result17_2, result17_3, result17_4, result17_5);
          if layout12.size() != 0 {
            _rt::alloc::dealloc(result12.cast(), layout12);
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Send a single request, then block (internally) until its response. The
      /// type returned is Message but will always contain Response.
      pub fn send_and_await_response(target: &Address,request: &Request,lazy_load_blob: Option<&LazyLoadBlob>,) -> Result<(Address,Message,),SendError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 112]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 112]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let Address{ node:node1, process:process1, } = target;
          let vec2 = node1;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          *ptr0.add(4).cast::<usize>() = len2;
          *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
          let ProcessId{ process_name:process_name3, package_name:package_name3, publisher_node:publisher_node3, } = process1;
          let vec4 = process_name3;
          let ptr4 = vec4.as_ptr().cast::<u8>();
          let len4 = vec4.len();
          *ptr0.add(12).cast::<usize>() = len4;
          *ptr0.add(8).cast::<*mut u8>() = ptr4.cast_mut();
          let vec5 = package_name3;
          let ptr5 = vec5.as_ptr().cast::<u8>();
          let len5 = vec5.len();
          *ptr0.add(20).cast::<usize>() = len5;
          *ptr0.add(16).cast::<*mut u8>() = ptr5.cast_mut();
          let vec6 = publisher_node3;
          let ptr6 = vec6.as_ptr().cast::<u8>();
          let len6 = vec6.len();
          *ptr0.add(28).cast::<usize>() = len6;
          *ptr0.add(24).cast::<*mut u8>() = ptr6.cast_mut();
          let Request{ inherit:inherit7, expects_response:expects_response7, body:body7, metadata:metadata7, capabilities:capabilities7, } = request;
          *ptr0.add(32).cast::<u8>() = (match inherit7 { true => 1, false => 0 }) as u8;
          match expects_response7 {
            Some(e) => {
              *ptr0.add(40).cast::<u8>() = (1i32) as u8;
              *ptr0.add(48).cast::<i64>() = _rt::as_i64(e);
            },
            None => {
              {
                *ptr0.add(40).cast::<u8>() = (0i32) as u8;
              }
            },
          };let vec8 = body7;
          let ptr8 = vec8.as_ptr().cast::<u8>();
          let len8 = vec8.len();
          *ptr0.add(60).cast::<usize>() = len8;
          *ptr0.add(56).cast::<*mut u8>() = ptr8.cast_mut();
          match metadata7 {
            Some(e) => {
              *ptr0.add(64).cast::<u8>() = (1i32) as u8;
              let vec9 = e;
              let ptr9 = vec9.as_ptr().cast::<u8>();
              let len9 = vec9.len();
              *ptr0.add(72).cast::<usize>() = len9;
              *ptr0.add(68).cast::<*mut u8>() = ptr9.cast_mut();
            },
            None => {
              {
                *ptr0.add(64).cast::<u8>() = (0i32) as u8;
              }
            },
          };let vec18 = capabilities7;
          let len18 = vec18.len();
          let layout18 = _rt::alloc::Layout::from_size_align_unchecked(vec18.len() * 40, 4);
          let result18 = if layout18.size() != 0 {
            let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout18);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec18.into_iter().enumerate() {
            let base = result18.add(i * 40);
            {
              let Capability{ issuer:issuer10, params:params10, } = e;
              let Address{ node:node11, process:process11, } = issuer10;
              let vec12 = node11;
              let ptr12 = vec12.as_ptr().cast::<u8>();
              let len12 = vec12.len();
              *base.add(4).cast::<usize>() = len12;
              *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
              let ProcessId{ process_name:process_name13, package_name:package_name13, publisher_node:publisher_node13, } = process11;
              let vec14 = process_name13;
              let ptr14 = vec14.as_ptr().cast::<u8>();
              let len14 = vec14.len();
              *base.add(12).cast::<usize>() = len14;
              *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
              let vec15 = package_name13;
              let ptr15 = vec15.as_ptr().cast::<u8>();
              let len15 = vec15.len();
              *base.add(20).cast::<usize>() = len15;
              *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
              let vec16 = publisher_node13;
              let ptr16 = vec16.as_ptr().cast::<u8>();
              let len16 = vec16.len();
              *base.add(28).cast::<usize>() = len16;
              *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
              let vec17 = params10;
              let ptr17 = vec17.as_ptr().cast::<u8>();
              let len17 = vec17.len();
              *base.add(36).cast::<usize>() = len17;
              *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
            }
          }
          *ptr0.add(80).cast::<usize>() = len18;
          *ptr0.add(76).cast::<*mut u8>() = result18;
          match lazy_load_blob {
            Some(e) => {
              *ptr0.add(88).cast::<u8>() = (1i32) as u8;
              let LazyLoadBlob{ mime:mime19, bytes:bytes19, } = e;
              match mime19 {
                Some(e) => {
                  *ptr0.add(92).cast::<u8>() = (1i32) as u8;
                  let vec20 = e;
                  let ptr20 = vec20.as_ptr().cast::<u8>();
                  let len20 = vec20.len();
                  *ptr0.add(100).cast::<usize>() = len20;
                  *ptr0.add(96).cast::<*mut u8>() = ptr20.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(92).cast::<u8>() = (0i32) as u8;
                  }
                },
              };let vec21 = bytes19;
              let ptr21 = vec21.as_ptr().cast::<u8>();
              let len21 = vec21.len();
              *ptr0.add(108).cast::<usize>() = len21;
              *ptr0.add(104).cast::<*mut u8>() = ptr21.cast_mut();
            },
            None => {
              {
                *ptr0.add(88).cast::<u8>() = (0i32) as u8;
              }
            },
          };let ptr22 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "kinode:process/standard@0.7.0")]
          extern "C" {
            #[link_name = "send-and-await-response"]
            fn wit_import(_: *mut u8, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0, ptr22);
          let l23 = i32::from(*ptr22.add(0).cast::<u8>());
          if layout18.size() != 0 {
            _rt::alloc::dealloc(result18.cast(), layout18);
          }
          match l23 {
            0 => {
              let e = {
                let l24 = *ptr22.add(8).cast::<*mut u8>();
                let l25 = *ptr22.add(12).cast::<usize>();
                let len26 = l25;
                let bytes26 = _rt::Vec::from_raw_parts(l24.cast(), len26, len26);
                let l27 = *ptr22.add(16).cast::<*mut u8>();
                let l28 = *ptr22.add(20).cast::<usize>();
                let len29 = l28;
                let bytes29 = _rt::Vec::from_raw_parts(l27.cast(), len29, len29);
                let l30 = *ptr22.add(24).cast::<*mut u8>();
                let l31 = *ptr22.add(28).cast::<usize>();
                let len32 = l31;
                let bytes32 = _rt::Vec::from_raw_parts(l30.cast(), len32, len32);
                let l33 = *ptr22.add(32).cast::<*mut u8>();
                let l34 = *ptr22.add(36).cast::<usize>();
                let len35 = l34;
                let bytes35 = _rt::Vec::from_raw_parts(l33.cast(), len35, len35);
                let l36 = i32::from(*ptr22.add(40).cast::<u8>());
                let v95 = match l36 {
                  0 => {
                    let e95 = {
                      let l37 = i32::from(*ptr22.add(48).cast::<u8>());
                      let l38 = i32::from(*ptr22.add(56).cast::<u8>());
                      let l40 = *ptr22.add(72).cast::<*mut u8>();
                      let l41 = *ptr22.add(76).cast::<usize>();
                      let len42 = l41;
                      let l43 = i32::from(*ptr22.add(80).cast::<u8>());
                      let l47 = *ptr22.add(92).cast::<*mut u8>();
                      let l48 = *ptr22.add(96).cast::<usize>();
                      let base64 = l47;
                      let len64 = l48;
                      let mut result64 = _rt::Vec::with_capacity(len64);
                      for i in 0..len64 {
                        let base = base64.add(i * 40);
                        let e64 = {
                          let l49 = *base.add(0).cast::<*mut u8>();
                          let l50 = *base.add(4).cast::<usize>();
                          let len51 = l50;
                          let bytes51 = _rt::Vec::from_raw_parts(l49.cast(), len51, len51);
                          let l52 = *base.add(8).cast::<*mut u8>();
                          let l53 = *base.add(12).cast::<usize>();
                          let len54 = l53;
                          let bytes54 = _rt::Vec::from_raw_parts(l52.cast(), len54, len54);
                          let l55 = *base.add(16).cast::<*mut u8>();
                          let l56 = *base.add(20).cast::<usize>();
                          let len57 = l56;
                          let bytes57 = _rt::Vec::from_raw_parts(l55.cast(), len57, len57);
                          let l58 = *base.add(24).cast::<*mut u8>();
                          let l59 = *base.add(28).cast::<usize>();
                          let len60 = l59;
                          let bytes60 = _rt::Vec::from_raw_parts(l58.cast(), len60, len60);
                          let l61 = *base.add(32).cast::<*mut u8>();
                          let l62 = *base.add(36).cast::<usize>();
                          let len63 = l62;
                          let bytes63 = _rt::Vec::from_raw_parts(l61.cast(), len63, len63);

                          Capability{
                            issuer: Address{
                              node: _rt::string_lift(bytes51),
                              process: ProcessId{
                                process_name: _rt::string_lift(bytes54),
                                package_name: _rt::string_lift(bytes57),
                                publisher_node: _rt::string_lift(bytes60),
                              },
                            },
                            params: _rt::string_lift(bytes63),
                          }
                        };
                        result64.push(e64);
                      }
                      _rt::cabi_dealloc(base64, len64 * 40, 4);

                      Request{
                        inherit: _rt::bool_lift(l37 as u8),
                        expects_response: match l38 {
                          0 => None,
                          1 => {
                            let e = {
                              let l39 = *ptr22.add(64).cast::<i64>();

                              l39 as u64
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        body: _rt::Vec::from_raw_parts(l40.cast(), len42, len42),
                        metadata: match l43 {
                          0 => None,
                          1 => {
                            let e = {
                              let l44 = *ptr22.add(84).cast::<*mut u8>();
                              let l45 = *ptr22.add(88).cast::<usize>();
                              let len46 = l45;
                              let bytes46 = _rt::Vec::from_raw_parts(l44.cast(), len46, len46);

                              _rt::string_lift(bytes46)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        capabilities: result64,
                      }
                    };
                    Message::Request(e95)
                  }
                  n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e95 = {
                      let l65 = i32::from(*ptr22.add(48).cast::<u8>());
                      let l66 = *ptr22.add(52).cast::<*mut u8>();
                      let l67 = *ptr22.add(56).cast::<usize>();
                      let len68 = l67;
                      let l69 = i32::from(*ptr22.add(60).cast::<u8>());
                      let l73 = *ptr22.add(72).cast::<*mut u8>();
                      let l74 = *ptr22.add(76).cast::<usize>();
                      let base90 = l73;
                      let len90 = l74;
                      let mut result90 = _rt::Vec::with_capacity(len90);
                      for i in 0..len90 {
                        let base = base90.add(i * 40);
                        let e90 = {
                          let l75 = *base.add(0).cast::<*mut u8>();
                          let l76 = *base.add(4).cast::<usize>();
                          let len77 = l76;
                          let bytes77 = _rt::Vec::from_raw_parts(l75.cast(), len77, len77);
                          let l78 = *base.add(8).cast::<*mut u8>();
                          let l79 = *base.add(12).cast::<usize>();
                          let len80 = l79;
                          let bytes80 = _rt::Vec::from_raw_parts(l78.cast(), len80, len80);
                          let l81 = *base.add(16).cast::<*mut u8>();
                          let l82 = *base.add(20).cast::<usize>();
                          let len83 = l82;
                          let bytes83 = _rt::Vec::from_raw_parts(l81.cast(), len83, len83);
                          let l84 = *base.add(24).cast::<*mut u8>();
                          let l85 = *base.add(28).cast::<usize>();
                          let len86 = l85;
                          let bytes86 = _rt::Vec::from_raw_parts(l84.cast(), len86, len86);
                          let l87 = *base.add(32).cast::<*mut u8>();
                          let l88 = *base.add(36).cast::<usize>();
                          let len89 = l88;
                          let bytes89 = _rt::Vec::from_raw_parts(l87.cast(), len89, len89);

                          Capability{
                            issuer: Address{
                              node: _rt::string_lift(bytes77),
                              process: ProcessId{
                                process_name: _rt::string_lift(bytes80),
                                package_name: _rt::string_lift(bytes83),
                                publisher_node: _rt::string_lift(bytes86),
                              },
                            },
                            params: _rt::string_lift(bytes89),
                          }
                        };
                        result90.push(e90);
                      }
                      _rt::cabi_dealloc(base90, len90 * 40, 4);
                      let l91 = i32::from(*ptr22.add(80).cast::<u8>());

                      (Response{
                        inherit: _rt::bool_lift(l65 as u8),
                        body: _rt::Vec::from_raw_parts(l66.cast(), len68, len68),
                        metadata: match l69 {
                          0 => None,
                          1 => {
                            let e = {
                              let l70 = *ptr22.add(64).cast::<*mut u8>();
                              let l71 = *ptr22.add(68).cast::<usize>();
                              let len72 = l71;
                              let bytes72 = _rt::Vec::from_raw_parts(l70.cast(), len72, len72);

                              _rt::string_lift(bytes72)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        capabilities: result90,
                      }, match l91 {
                        0 => None,
                        1 => {
                          let e = {
                            let l92 = *ptr22.add(84).cast::<*mut u8>();
                            let l93 = *ptr22.add(88).cast::<usize>();
                            let len94 = l93;

                            _rt::Vec::from_raw_parts(l92.cast(), len94, len94)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      })
                    };
                    Message::Response(e95)
                  }
                };

                (Address{
                  node: _rt::string_lift(bytes26),
                  process: ProcessId{
                    process_name: _rt::string_lift(bytes29),
                    package_name: _rt::string_lift(bytes32),
                    publisher_node: _rt::string_lift(bytes35),
                  },
                }, v95)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l96 = i32::from(*ptr22.add(8).cast::<u8>());
                let l97 = i32::from(*ptr22.add(16).cast::<u8>());
                let v156 = match l97 {
                  0 => {
                    let e156 = {
                      let l98 = i32::from(*ptr22.add(24).cast::<u8>());
                      let l99 = i32::from(*ptr22.add(32).cast::<u8>());
                      let l101 = *ptr22.add(48).cast::<*mut u8>();
                      let l102 = *ptr22.add(52).cast::<usize>();
                      let len103 = l102;
                      let l104 = i32::from(*ptr22.add(56).cast::<u8>());
                      let l108 = *ptr22.add(68).cast::<*mut u8>();
                      let l109 = *ptr22.add(72).cast::<usize>();
                      let base125 = l108;
                      let len125 = l109;
                      let mut result125 = _rt::Vec::with_capacity(len125);
                      for i in 0..len125 {
                        let base = base125.add(i * 40);
                        let e125 = {
                          let l110 = *base.add(0).cast::<*mut u8>();
                          let l111 = *base.add(4).cast::<usize>();
                          let len112 = l111;
                          let bytes112 = _rt::Vec::from_raw_parts(l110.cast(), len112, len112);
                          let l113 = *base.add(8).cast::<*mut u8>();
                          let l114 = *base.add(12).cast::<usize>();
                          let len115 = l114;
                          let bytes115 = _rt::Vec::from_raw_parts(l113.cast(), len115, len115);
                          let l116 = *base.add(16).cast::<*mut u8>();
                          let l117 = *base.add(20).cast::<usize>();
                          let len118 = l117;
                          let bytes118 = _rt::Vec::from_raw_parts(l116.cast(), len118, len118);
                          let l119 = *base.add(24).cast::<*mut u8>();
                          let l120 = *base.add(28).cast::<usize>();
                          let len121 = l120;
                          let bytes121 = _rt::Vec::from_raw_parts(l119.cast(), len121, len121);
                          let l122 = *base.add(32).cast::<*mut u8>();
                          let l123 = *base.add(36).cast::<usize>();
                          let len124 = l123;
                          let bytes124 = _rt::Vec::from_raw_parts(l122.cast(), len124, len124);

                          Capability{
                            issuer: Address{
                              node: _rt::string_lift(bytes112),
                              process: ProcessId{
                                process_name: _rt::string_lift(bytes115),
                                package_name: _rt::string_lift(bytes118),
                                publisher_node: _rt::string_lift(bytes121),
                              },
                            },
                            params: _rt::string_lift(bytes124),
                          }
                        };
                        result125.push(e125);
                      }
                      _rt::cabi_dealloc(base125, len125 * 40, 4);

                      Request{
                        inherit: _rt::bool_lift(l98 as u8),
                        expects_response: match l99 {
                          0 => None,
                          1 => {
                            let e = {
                              let l100 = *ptr22.add(40).cast::<i64>();

                              l100 as u64
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        body: _rt::Vec::from_raw_parts(l101.cast(), len103, len103),
                        metadata: match l104 {
                          0 => None,
                          1 => {
                            let e = {
                              let l105 = *ptr22.add(60).cast::<*mut u8>();
                              let l106 = *ptr22.add(64).cast::<usize>();
                              let len107 = l106;
                              let bytes107 = _rt::Vec::from_raw_parts(l105.cast(), len107, len107);

                              _rt::string_lift(bytes107)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        capabilities: result125,
                      }
                    };
                    Message::Request(e156)
                  }
                  n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e156 = {
                      let l126 = i32::from(*ptr22.add(24).cast::<u8>());
                      let l127 = *ptr22.add(28).cast::<*mut u8>();
                      let l128 = *ptr22.add(32).cast::<usize>();
                      let len129 = l128;
                      let l130 = i32::from(*ptr22.add(36).cast::<u8>());
                      let l134 = *ptr22.add(48).cast::<*mut u8>();
                      let l135 = *ptr22.add(52).cast::<usize>();
                      let base151 = l134;
                      let len151 = l135;
                      let mut result151 = _rt::Vec::with_capacity(len151);
                      for i in 0..len151 {
                        let base = base151.add(i * 40);
                        let e151 = {
                          let l136 = *base.add(0).cast::<*mut u8>();
                          let l137 = *base.add(4).cast::<usize>();
                          let len138 = l137;
                          let bytes138 = _rt::Vec::from_raw_parts(l136.cast(), len138, len138);
                          let l139 = *base.add(8).cast::<*mut u8>();
                          let l140 = *base.add(12).cast::<usize>();
                          let len141 = l140;
                          let bytes141 = _rt::Vec::from_raw_parts(l139.cast(), len141, len141);
                          let l142 = *base.add(16).cast::<*mut u8>();
                          let l143 = *base.add(20).cast::<usize>();
                          let len144 = l143;
                          let bytes144 = _rt::Vec::from_raw_parts(l142.cast(), len144, len144);
                          let l145 = *base.add(24).cast::<*mut u8>();
                          let l146 = *base.add(28).cast::<usize>();
                          let len147 = l146;
                          let bytes147 = _rt::Vec::from_raw_parts(l145.cast(), len147, len147);
                          let l148 = *base.add(32).cast::<*mut u8>();
                          let l149 = *base.add(36).cast::<usize>();
                          let len150 = l149;
                          let bytes150 = _rt::Vec::from_raw_parts(l148.cast(), len150, len150);

                          Capability{
                            issuer: Address{
                              node: _rt::string_lift(bytes138),
                              process: ProcessId{
                                process_name: _rt::string_lift(bytes141),
                                package_name: _rt::string_lift(bytes144),
                                publisher_node: _rt::string_lift(bytes147),
                              },
                            },
                            params: _rt::string_lift(bytes150),
                          }
                        };
                        result151.push(e151);
                      }
                      _rt::cabi_dealloc(base151, len151 * 40, 4);
                      let l152 = i32::from(*ptr22.add(56).cast::<u8>());

                      (Response{
                        inherit: _rt::bool_lift(l126 as u8),
                        body: _rt::Vec::from_raw_parts(l127.cast(), len129, len129),
                        metadata: match l130 {
                          0 => None,
                          1 => {
                            let e = {
                              let l131 = *ptr22.add(40).cast::<*mut u8>();
                              let l132 = *ptr22.add(44).cast::<usize>();
                              let len133 = l132;
                              let bytes133 = _rt::Vec::from_raw_parts(l131.cast(), len133, len133);

                              _rt::string_lift(bytes133)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        capabilities: result151,
                      }, match l152 {
                        0 => None,
                        1 => {
                          let e = {
                            let l153 = *ptr22.add(60).cast::<*mut u8>();
                            let l154 = *ptr22.add(64).cast::<usize>();
                            let len155 = l154;

                            _rt::Vec::from_raw_parts(l153.cast(), len155, len155)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      })
                    };
                    Message::Response(e156)
                  }
                };
                let l157 = i32::from(*ptr22.add(80).cast::<u8>());

                SendError{
                  kind: SendErrorKind::_lift(l96 as u8),
                  message: v156,
                  lazy_load_blob: match l157 {
                    0 => None,
                    1 => {
                      let e = {
                        let l158 = i32::from(*ptr22.add(84).cast::<u8>());
                        let l162 = *ptr22.add(96).cast::<*mut u8>();
                        let l163 = *ptr22.add(100).cast::<usize>();
                        let len164 = l163;

                        LazyLoadBlob{
                          mime: match l158 {
                            0 => None,
                            1 => {
                              let e = {
                                let l159 = *ptr22.add(88).cast::<*mut u8>();
                                let l160 = *ptr22.add(92).cast::<usize>();
                                let len161 = l160;
                                let bytes161 = _rt::Vec::from_raw_parts(l159.cast(), len161, len161);

                                _rt::string_lift(bytes161)
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                          bytes: _rt::Vec::from_raw_parts(l162.cast(), len164, len164),
                        }
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Address = super::super::super::kinode::process::standard::Address;
      #[derive(Clone)]
      pub struct FileInfo {
        pub name: _rt::String,
        pub size: u64,
      }
      impl ::core::fmt::Debug for FileInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("FileInfo").field("name", &self.name).field("size", &self.size).finish()
        }
      }
      #[derive(Clone)]
      pub struct TransferDownload {
        pub name: _rt::String,
        pub target: Address,
      }
      impl ::core::fmt::Debug for TransferDownload {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("TransferDownload").field("name", &self.name).field("target", &self.target).finish()
        }
      }
      #[derive(Clone)]
      pub enum TransferResponse {
        ListFiles(_rt::Vec::<FileInfo>),
        Download(TransferDownload),
        Done,
        Started,
      }
      impl ::core::fmt::Debug for TransferResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            TransferResponse::ListFiles(e) => {
              f.debug_tuple("TransferResponse::ListFiles").field(e).finish()
            }
            TransferResponse::Download(e) => {
              f.debug_tuple("TransferResponse::Download").field(e).finish()
            }
            TransferResponse::Done => {
              f.debug_tuple("TransferResponse::Done").finish()
            }
            TransferResponse::Started => {
              f.debug_tuple("TransferResponse::Started").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct TransferRequestProgress {
        pub name: _rt::String,
        pub progress: u64,
      }
      impl ::core::fmt::Debug for TransferRequestProgress {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("TransferRequestProgress").field("name", &self.name).field("progress", &self.progress).finish()
        }
      }
      #[derive(Clone)]
      pub enum TransferRequest {
        ListFiles,
        Download(TransferDownload),
        Progress(TransferRequestProgress),
      }
      impl ::core::fmt::Debug for TransferRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            TransferRequest::ListFiles => {
              f.debug_tuple("TransferRequest::ListFiles").finish()
            }
            TransferRequest::Download(e) => {
              f.debug_tuple("TransferRequest::Download").field(e).finish()
            }
            TransferRequest::Progress(e) => {
              f.debug_tuple("TransferRequest::Progress").field(e).finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct WorkerRequestInitialize {
        pub name: _rt::String,
        pub target_worker: Option<Address>,
      }
      impl ::core::fmt::Debug for WorkerRequestInitialize {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("WorkerRequestInitialize").field("name", &self.name).field("target-worker", &self.target_worker).finish()
        }
      }
      #[derive(Clone)]
      pub struct WorkerRequestChunk {
        pub name: _rt::String,
        pub offset: u64,
        pub length: u64,
      }
      impl ::core::fmt::Debug for WorkerRequestChunk {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("WorkerRequestChunk").field("name", &self.name).field("offset", &self.offset).field("length", &self.length).finish()
        }
      }
      #[derive(Clone)]
      pub enum WorkerRequest {
        Initialize(WorkerRequestInitialize),
        Chunk(WorkerRequestChunk),
        Size(u64),
      }
      impl ::core::fmt::Debug for WorkerRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            WorkerRequest::Initialize(e) => {
              f.debug_tuple("WorkerRequest::Initialize").field(e).finish()
            }
            WorkerRequest::Chunk(e) => {
              f.debug_tuple("WorkerRequest::Chunk").field(e).finish()
            }
            WorkerRequest::Size(e) => {
              f.debug_tuple("WorkerRequest::Size").field(e).finish()
            }
          }
        }
      }

    }

  }
}
mod _rt {
  pub use alloc_crate::string::String;
  pub use alloc_crate::vec::Vec;

  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  pub fn as_i64<T: AsI64>(t: T) -> i64 {
    t.as_i64()
  }

  pub trait AsI64 {
    fn as_i64(self) -> i64;
  }

  impl<'a, T: Copy + AsI64> AsI64 for &'a T {
    fn as_i64(self) -> i64 {
      (*self).as_i64()
    }
  }
  
  impl AsI64 for i64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  impl AsI64 for u64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  pub use alloc_crate::alloc;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      String::from_utf8_unchecked(bytes)
    }
  }
  pub unsafe fn bool_lift(val: u8) -> bool {
    if cfg!(debug_assertions) {
      match val {
        0 => false,
        1 => true,
        _ => panic!("invalid bool discriminant"),
      }
    } else {
      val != 0
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      core::hint::unreachable_unchecked()
    }
  }
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    let layout = alloc::Layout::from_size_align_unchecked(size, align);
    alloc::dealloc(ptr as *mut u8, layout);
  }
  
  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen::rt::run_ctors_once();
  }
  extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_file_transfer_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::__export_world_file_transfer_cabi!($ty with_types_in $($path_to_types_root)*);
  )
}
#[doc(inline)]
pub(crate) use __export_file_transfer_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.24.0:file-transfer:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1932] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x88\x0e\x01A\x02\x01\
A\x07\x01BN\x01s\x04\0\x04json\x03\0\0\x01s\x04\0\x07node-id\x03\0\x02\x01p}\x04\
\0\x07context\x03\0\x04\x01r\x03\x0cprocess-names\x0cpackage-names\x0epublisher-\
node\x03\x04\0\x0aprocess-id\x03\0\x06\x01r\x02\x04node\x03\x07process\x07\x04\0\
\x07address\x03\0\x08\x01ks\x01p}\x01r\x02\x04mime\x0a\x05bytes\x0b\x04\0\x0elaz\
y-load-blob\x03\0\x0c\x01r\x02\x06issuer\x09\x06params\x01\x04\0\x0acapability\x03\
\0\x0e\x01kw\x01k\x01\x01p\x0f\x01r\x05\x07inherit\x7f\x10expects-response\x10\x04\
body\x0b\x08metadata\x11\x0ccapabilities\x12\x04\0\x07request\x03\0\x13\x01r\x04\
\x07inherit\x7f\x04body\x0b\x08metadata\x11\x0ccapabilities\x12\x04\0\x08respons\
e\x03\0\x15\x01k\x05\x01o\x02\x16\x17\x01q\x02\x07request\x01\x14\0\x08response\x01\
\x18\0\x04\0\x07message\x03\0\x19\x01k\x0d\x01o\x03\x09\x14\x1b\x01p\x1c\x01q\x03\
\x04none\0\0\x07restart\0\0\x08requests\x01\x1d\0\x04\0\x07on-exit\x03\0\x1e\x01\
m\x02\x07offline\x07timeout\x04\0\x0fsend-error-kind\x03\0\x20\x01r\x03\x04kind!\
\x07message\x1a\x0elazy-load-blob\x1b\x04\0\x0asend-error\x03\0\"\x01m\x02\x0ana\
me-taken\x0fno-file-at-path\x04\0\x0bspawn-error\x03\0$\x01@\x02\x09verbosity}\x07\
messages\x01\0\x04\0\x11print-to-terminal\x01&\x01@\x01\x07on-exit\x1f\x01\0\x04\
\0\x0bset-on-exit\x01'\x01@\0\0\x1f\x04\0\x0bget-on-exit\x01(\x01k\x0b\x01@\0\0)\
\x04\0\x09get-state\x01*\x01@\x01\x05bytes\x0b\x01\0\x04\0\x09set-state\x01+\x01\
@\0\x01\0\x04\0\x0bclear-state\x01,\x01p\x07\x01j\x01\x07\x01%\x01@\x06\x04name\x0a\
\x09wasm-paths\x07on-exit\x1f\x14request-capabilities\x12\x12grant-capabilities-\
\x06public\x7f\0.\x04\0\x05spawn\x01/\x01@\x01\x04caps\x12\x01\0\x04\0\x11save-c\
apabilities\x010\x04\0\x11drop-capabilities\x010\x01@\0\0\x12\x04\0\x10our-capab\
ilities\x011\x01o\x02\x09\x1a\x01o\x02#\x17\x01j\x012\x013\x01@\0\04\x04\0\x07re\
ceive\x015\x01@\0\0\x1b\x04\0\x08get-blob\x016\x01@\x04\x06target\x09\x07request\
\x14\x07context\x17\x0elazy-load-blob\x1b\x01\0\x04\0\x0csend-request\x017\x01o\x04\
\x09\x14\x17\x1b\x01p8\x01@\x01\x08requests9\x01\0\x04\0\x0dsend-requests\x01:\x01\
@\x02\x08response\x16\x0elazy-load-blob\x1b\x01\0\x04\0\x0dsend-response\x01;\x01\
j\x012\x01#\x01@\x03\x06target\x09\x07request\x14\x0elazy-load-blob\x1b\0<\x04\0\
\x17send-and-await-response\x01=\x03\x01\x1dkinode:process/standard@0.7.0\x05\0\x02\
\x03\0\0\x07address\x01B\x14\x02\x03\x02\x01\x01\x04\0\x07address\x03\0\0\x01r\x02\
\x04names\x04sizew\x04\0\x09file-info\x03\0\x02\x01r\x02\x04names\x06target\x01\x04\
\0\x11transfer-download\x03\0\x04\x01p\x03\x01q\x04\x0alist-files\x01\x06\0\x08d\
ownload\x01\x05\0\x04done\0\0\x07started\0\0\x04\0\x11transfer-response\x03\0\x07\
\x01r\x02\x04names\x08progressw\x04\0\x19transfer-request-progress\x03\0\x09\x01\
q\x03\x0alist-files\0\0\x08download\x01\x05\0\x08progress\x01\x0a\0\x04\0\x10tra\
nsfer-request\x03\0\x0b\x01k\x01\x01r\x02\x04names\x0dtarget-worker\x0d\x04\0\x19\
worker-request-initialize\x03\0\x0e\x01r\x03\x04names\x06offsetw\x06lengthw\x04\0\
\x14worker-request-chunk\x03\0\x10\x01q\x03\x0ainitialize\x01\x0f\0\x05chunk\x01\
\x11\0\x04size\x01w\0\x04\0\x0eworker-request\x03\0\x12\x03\x01\x18kinode:proces\
s/api@0.7.0\x05\x02\x01@\x01\x03ours\x01\0\x04\0\x04init\x01\x03\x04\x01\"kinode\
:process/file-transfer@0.7.0\x04\0\x0b\x13\x01\0\x0dfile-transfer\x03\0\0\0G\x09\
producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.202.0\x10wit-bindgen-rus\
t\x060.24.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

